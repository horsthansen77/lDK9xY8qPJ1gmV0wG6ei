<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Online-Spiel - Spiel mit Freunden (WebRTC Fixed)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: #333;
            min-height: 100vh;
            overflow-x: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .page {
            display: none;
            min-height: 100vh;
            padding: 20px;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .page.active {
            display: flex;
        }

        .container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
            max-width: 600px;
            width: 100%;
            text-align: center;
        }

        .game-container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 15px;
            max-width: 100vw;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 2rem;
        }

        h2 {
            color: #27ae60;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 10px 0;
            border: 2px solid #e9ecef;
        }

        .form-group {
            margin-bottom: 15px;
            text-align: left;
        }

        .form-group label {
            display: block;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .form-group select,
        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .form-group select:focus,
        .form-group input:focus {
            outline: none;
            border-color: #27ae60;
            box-shadow: 0 0 0 3px rgba(39, 174, 96, 0.1);
        }

        .invite-link {
            background: #e8f4fd;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #2c3e50;
            word-break: break-all;
            margin-bottom: 10px;
        }

        .btn {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
            width: 100%;
            margin: 10px 0;
            touch-action: manipulation;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
            cursor: not-allowed;
            transform: none;
        }

        .btn.danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .btn.warning {
            background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%);
            color: #212529;
        }

        .btn.copy-btn {
            padding: 8px 15px;
            font-size: 14px;
            margin: 5px 0;
        }

        .color-choice {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
        }

        .color-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            border: 3px solid transparent;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
            min-width: 120px;
            touch-action: manipulation;
        }

        .color-option:hover {
            transform: scale(1.05);
        }

        .color-option.selected {
            border-color: #27ae60;
            background: #d4edda;
        }

        .color-option.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .color-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .color-preview.black {
            background: radial-gradient(circle at 30% 30%, #666, #000);
        }

        .color-preview.white {
            background: radial-gradient(circle at 30% 30%, #fff, #ccc);
            color: #333;
            text-shadow: none;
        }

        .status-message {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: bold;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .debug-info {
            background: #e2e3e5;
            border: 1px solid #d1d3d4;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 150px;
            overflow-y: auto;
            text-align: left;
        }

        /* Game Room Styles */
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 15px;
            background: #f8f9fa;
            border-radius: 20px;
            border: 2px solid #e9ecef;
        }

        .player-info.active {
            border-color: #27ae60;
            background: #d4edda;
        }

        .player-color {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .orbito-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 3px;
            background: #333;
            border-radius: 15px;
            padding: 15px;
            position: relative;
            margin: 10px auto;
            max-width: min(90vw, 400px);
            aspect-ratio: 1;
        }

        .field {
            background: #fff;
            border: 3px solid #ddd;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            aspect-ratio: 1;
            transition: all 0.3s ease;
            touch-action: manipulation;
        }

        .field.outer-ring {
            border-color: #dc3545;
            background: #fff5f5;
        }

        .field.inner-ring {
            border-color: #ffc107;
            background: #fffaf0;
        }

        .field.valid-move {
            border-color: #27ae60 !important;
            background: #d4edda !important;
            animation: pulse 1s infinite;
        }

        .field.magnetic {
            border-color: #007bff !important;
            background: #cce7ff !important;
            transform: scale(1.05);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .field-label {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 10px;
            color: #999;
            pointer-events: none;
        }

        .ball {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            font-size: 1.5rem;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
            touch-action: manipulation;
        }

        .ball.black {
            background: radial-gradient(circle at 30% 30%, #666, #000);
            border-color: #ffd700;
        }

        .ball.white {
            background: radial-gradient(circle at 30% 30%, #fff, #ccc);
            color: #333;
            text-shadow: none;
        }

        .ball.dragging {
            transform: scale(1.2);
            z-index: 1000;
            opacity: 0.8;
        }

        .ball.selected {
            border-color: #ff6b6b !important;
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.8);
        }

        .ball.confirm-needed {
            animation: confirmBlink 1s infinite;
        }

        @keyframes confirmBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .orbito-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #ff6b6b, #ee5a52);
            border: none;
            border-radius: 50%;
            color: white;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            font-size: 16px;
            transition: all 0.2s ease;
            z-index: 100;
            touch-action: manipulation;
        }

        .orbito-button:hover {
            transform: translate(-50%, -50%) scale(1.1);
        }

        .orbito-button:active {
            transform: translate(-50%, -50%) scale(0.95);
        }

        .orbito-button.active {
            background: radial-gradient(circle, #27ae60, #2ecc71);
            animation: buttonPulse 1s infinite;
        }

        .orbito-button.disabled {
            background: radial-gradient(circle, #95a5a6, #7f8c8d);
            cursor: not-allowed;
            opacity: 0.6;
        }

        @keyframes buttonPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        .ball-storage {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            justify-content: center;
            min-height: 80px;
        }

        .storage-ball {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
        }

        .storage-ball:hover {
            transform: scale(1.1);
        }

        .game-status {
            background: #e8f4fd;
            border: 2px solid #3498db;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }

        .chat-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-top: 2px solid #e9ecef;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 1000;
            max-height: 40vh;
            display: flex;
            flex-direction: column;
        }

        .chat-container.open {
            transform: translateY(0);
        }

        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .chat-messages {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            max-height: 200px;
        }

        .chat-message {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 8px;
            background: #f8f9fa;
        }

        .chat-input-container {
            display: flex;
            padding: 10px;
            gap: 10px;
            border-top: 1px solid #e9ecef;
        }

        .chat-input {
            flex: 1;
            padding: 10px;
            border: 1px solid #e9ecef;
            border-radius: 20px;
            outline: none;
        }

        .chat-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1001;
            touch-action: manipulation;
        }

        .notification {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .winning-line {
            background: linear-gradient(45deg, #27ae60, #2ecc71) !important;
            animation: winPulse 2s infinite;
        }

        @keyframes winPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
            }

            .game-container {
                padding: 10px;
                margin: 0;
                border-radius: 0;
            }

            .orbito-board {
                max-width: 90vw;
            }

            .ball {
                font-size: 1.2rem;
            }

            .storage-ball {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }

            .color-choice {
                flex-direction: column;
                gap: 10px;
            }

            .color-option {
                min-width: 100px;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.5rem;
            }

            .btn {
                font-size: 16px;
                padding: 12px 20px;
            }

            .orbito-button {
                width: 50px;
                height: 50px;
                font-size: 14px;
            }
        }

        /* Touch feedback */
        .btn:active,
        .color-option:active,
        .ball:active,
        .orbito-button:active {
            transform: scale(0.95);
        }

        /* Loading animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Seite 1: WebRTC Setup -->
    <div class="page active" id="setupPage">
        <div class="container">
            <h1>🎯 Online-Spiel (WebRTC Fixed)</h1>
            
            <div class="section">
                <h2>1. WebRTC-Server auswählen</h2>
                <div class="form-group">
                    <label for="stunServer">Kostenloser WebRTC-Server:</label>
                    <select id="stunServer">
                        <option value="stun:stun.l.google.com:19302">Google STUN (Empfohlen)</option>
                        <option value="stun:stun.services.mozilla.com">Mozilla STUN</option>
                        <option value="stun:global.stun.twilio.com:3478">Twilio STUN</option>
                        <option value="stun:xirsys.com">Xirsys STUN</option>
                        <option value="stun:relay.backups.cz">Open Relay Project</option>
                    </select>
                </div>
            </div>

            <div class="section">
                <h2>2. Einladung für Freunde</h2>
                
                <!-- HTTPS-Modus: URL + Code -->
                <div id="httpsMode" style="display: none;">
                    <h3 style="color: #27ae60; margin-bottom: 15px;">📲 Einladungslink (empfohlen)</h3>
                    <div class="invite-link" id="inviteLink">Link wird generiert...</div>
                    <button class="btn copy-btn" onclick="copyInviteLink()">📋 Link kopieren</button>
                    <p style="margin: 10px 0; color: #666; font-size: 14px;">
                        Teilen Sie diesen Link mit Ihrem Mitspieler. Er kann direkt beitreten!
                    </p>
                    
                    <hr style="margin: 20px 0; border: 1px solid #e9ecef;">
                    <h3 style="color: #ffc107; margin-bottom: 10px;">🔢 Alternativ: Spielcode</h3>
                </div>
                
                <!-- File-Modus: Nur Code -->
                <div id="fileMode" style="display: none;">
                    <h3 style="color: #27ae60; margin-bottom: 10px;">🔢 Ihr Spielcode</h3>
                </div>
                
                <!-- Code-System (beide Modi) -->
                <div style="text-align: center; margin: 15px 0;">
                    <div class="invite-link" id="gameCodeDisplay" style="font-size: 24px; font-weight: bold; color: #2c3e50; letter-spacing: 3px;">CODE-WIRD-GENERIERT</div>
                    <button class="btn copy-btn" onclick="copyGameCode()">📋 Code kopieren</button>
                </div>
                
            <div style="background: #e8f4fd; border: 2px solid #3498db; border-radius: 10px; padding: 15px; margin: 15px 0;">
                <h4 style="margin-bottom: 10px; color: #2c3e50;">📱 So funktioniert der Code:</h4>
                <ol style="text-align: left; margin: 0; padding-left: 20px; color: #495057; line-height: 1.6;">
                    <li><strong>Teilen Sie den 6-stelligen Code</strong> mit Ihrem Freund</li>
                    <li id="codeInstructionFile" style="display: none;"><strong>Ihr Freund öffnet dieselbe HTML-Datei</strong> auf seinem Gerät</li>
                    <li id="codeInstructionHttps" style="display: none;"><strong>Ihr Freund öffnet dieselbe Webseite</strong> im Browser</li>
                    <li><strong>Ihr Freund gibt den Code ein</strong> statt einen Link zu klicken</li>
                    <li><strong>Verbindung wird automatisch hergestellt!</strong> 🎉</li>
                </ol>
            </div>
            
            <div style="background: #e8f4fd; border: 2px solid #3498db; border-radius: 10px; padding: 15px; margin: 15px 0;">
                <h4 style="margin-bottom: 10px; color: #2c3e50;">🔧 Debug & Test-Tipps:</h4>
                <ul style="text-align: left; margin: 0; padding-left: 20px; color: #495057; line-height: 1.6;">
                    <li><strong>Für Tests:</strong> Verschiedene Browser verwenden (Chrome + Firefox)</li>
                    <li><strong>Oder:</strong> Normal + Inkognito-Modus im selben Browser</li>
                    <li><strong>NICHT:</strong> Zwei normale Tabs - localStorage-Konflikt!</li>
                    <li><strong>Ideal:</strong> Verschiedene Geräte (PC + Smartphone)</li>
                </ul>
                <button class="btn copy-btn" onclick="clearDebugData()" style="margin-top: 10px;">🧹 Debug-Daten löschen</button>
            </div>
                
                <div id="fileModeWarning" style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 10px; font-size: 14px; color: #856404; display: none;">
                    <strong>💡 Lokale Datei:</strong> Da Sie eine lokale HTML-Datei verwenden, funktionieren nur Codes. Für Einladungslinks hosten Sie die Datei online (z.B. GitHub Pages).
                </div>
            </div>

            <!-- Debug-Bereich -->
            <div id="debugSection" style="display: none;">
                <div class="section">
                    <h2>🔧 Debug-Informationen</h2>
                    <div class="debug-info" id="debugLog">
                        Debug-Log wird hier angezeigt...
                    </div>
                    <button class="btn copy-btn" onclick="toggleDebug()">Debug ein/aus</button>
                </div>
            </div>

            <button class="btn" onclick="goToPlayerSetup()">
                🎯 Als Host starten (Code teilen)
            </button>
            
            <button class="btn warning" onclick="goToJoining()" id="joinButton">
                🔗 Spiel beitreten (Code eingeben)
            </button>
            
            <div id="hybridInfo" style="background: #d1ecf1; border: 2px solid #17a2b8; border-radius: 8px; padding: 10px; margin-top: 15px; font-size: 14px; color: #0c5460; display: none;">
                <strong>🚀 HYBRID-MODUS:</strong> <span id="hybridModeText"></span>
            </div>
        </div>
    </div>

    <!-- Seite 2: Spieler Setup -->
    <div class="page" id="playerPage">
        <div class="container">
            <h1>🎮 Spieler-Setup</h1>
            
            <!-- Code-Eingabe für Joining Players -->
            <div class="section" id="codeJoinSection" style="display: none;">
                <h2>🔗 Spiel beitreten</h2>
                <div class="form-group">
                    <label for="gameCodeInput">6-stelliger Spielcode:</label>
                    <input type="text" id="gameCodeInput" placeholder="z.B. ABC123" maxlength="6" style="text-transform: uppercase; text-align: center; font-size: 18px; letter-spacing: 2px;" autocomplete="off" autocorrect="off" autocapitalize="characters" spellcheck="false">
                </div>
                <button class="btn" onclick="joinWithCode()">🎯 Mit Code beitreten</button>
                <div id="joinStatus" class="status-message" style="display: none;"></div>
            </div>
            
            <div class="section">
                <h2>Ihr Name</h2>
                <div class="form-group">
                    <input type="text" id="playerName" placeholder="Geben Sie Ihren Namen ein..." maxlength="20">
                </div>
            </div>

            <div class="section">
                <h2>Kugelfarbe wählen</h2>
                <div class="color-choice">
                    <div class="color-option" onclick="selectColor('black')" id="blackOption">
                        <div class="color-preview black">⚫</div>
                        <div>SCHWARZ</div>
                    </div>
                    <div class="color-option" onclick="selectColor('white')" id="whiteOption">
                        <div class="color-preview white">⚪</div>
                        <div>WEISS</div>
                    </div>
                </div>
                <div id="colorStatus" class="status-message" style="display: none;"></div>
            </div>

            <div id="connectionStatus" class="status-message status-warning" style="display: none;">
                <div class="loading"></div> Verbindung wird hergestellt...
            </div>
            
            <div id="hostWaitingStatus" class="status-message status-success" style="display: none;">
                ✅ <strong>Host-Modus aktiv!</strong><br>
                📤 Teilen Sie Ihren 6-stelligen Code mit einem Freund<br>
                ⏳ Warten Sie, bis Ihr Freund den Code eingibt und beitritt<br>
                🔗 Erst dann wird die P2P-Verbindung hergestellt
            </div>

            <button class="btn" id="enterGameBtn" onclick="enterGame()" disabled>
                Online-Spiel-Raum betreten
            </button>
        </div>
    </div>

    <!-- Seite 3: Spielraum -->
    <div class="page" id="gamePage">
        <div class="game-container">
            <!-- Spieler-Info Header -->
            <div class="game-header">
                <div class="player-info" id="player1Info">
                    <div class="player-color black">⚫</div>
                    <span id="player1Name">Spieler 1</span>
                </div>
                <div class="player-info" id="player2Info">
                    <div class="player-color white">⚪</div>
                    <span id="player2Name">Spieler 2</span>
                </div>
            </div>

            <!-- Spielstatus -->
            <div class="game-status" id="gameStatus">
                Warten auf Mitspieler...
            </div>

            <!-- Kugelvorrat für lokalen Spieler -->
            <div id="ballStorage" class="ball-storage">
                <!-- Wird dynamisch gefüllt -->
            </div>

            <!-- Spielbrett -->
            <div class="orbito-board" id="orbitoBoard">
                <button class="orbito-button disabled" id="orbitoButton" onclick="executeOrbito()">⟲</button>
                <!-- Felder A1-D4 -->
            </div>

            <!-- Kugelvorrat für Gegner -->
            <div id="opponentStorage" class="ball-storage">
                <!-- Wird dynamisch gefüllt -->
            </div>
        </div>

        <!-- Chat Toggle Button -->
        <button class="chat-toggle" id="chatToggle" onclick="toggleChat()">
            💬
            <div class="notification" id="chatNotification" style="display: none;">0</div>
        </button>

        <!-- Chat Container -->
        <div class="chat-container" id="chatContainer">
            <div class="chat-header">
                <h3>💬 Chat</h3>
                <button onclick="toggleChat()" style="background: none; border: none; font-size: 18px; cursor: pointer;">✖️</button>
            </div>
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input-container">
                <input type="text" id="chatInput" class="chat-input" placeholder="Nachricht eingeben..." maxlength="100" onkeypress="if(event.key==='Enter') sendChatMessage()">
                <button class="btn" onclick="sendChatMessage()" style="width: auto; margin: 0; padding: 10px 20px;">Senden</button>
            </div>
        </div>
    </div>

    <script>
        // ==================================================================================
        // GLOBALE VARIABLEN
        // ==================================================================================
        
        // WebRTC Variablen
        let peerConnection = null;
        let dataChannel = null;
        let isHost = false;
        let localPeerReady = false;
        let remotePeerReady = false;
        let connectionEstablished = false;
        
        // Tracking Variablen für bessere Verbindung
        let iceCandidatesReceived = [];
        let iceCandidatesSent = [];
        let connectionAttempts = 0;
        let maxConnectionAttempts = 5;
        let debugMode = false;
        
        // Spiel Variablen
        let gameBoard = {};
        let gameHistory = [];
        let gameMoves = []; // Für Simulator-Export
        let currentPlayer = 'black'; // Wer ist am Zug
        let localPlayerColor = null; // Farbe des lokalen Spielers
        let localPlayerName = '';
        let remotePlayerName = '';
        let remotePlayerColor = null;
        let gamePhase = 'waiting'; // waiting, playing, finished
        let selectedBall = null;
        let moveStep = 'umsetzen'; // umsetzen, platzieren, orbito
        let ballsPlaced = 0;
        let gameWon = false;
        let endgameRotations = 0;
        let currentMove = null; // Aktueller Zug wird aufgebaut
        
        // Touch/Drag Variablen
        let isDragging = false;
        let dragElement = null;
        let dragOffset = { x: 0, y: 0 };
        let confirmNeeded = null;
        
        // Chat Variablen
        let chatOpen = false;
        let unreadMessages = 0;
        
        // Ring-Definitionen (aus Simulator übernommen)
        const outerRing = ["A1", "A2", "A3", "A4", "B4", "C4", "D4", "D3", "D2", "D1", "C1", "B1"];
        const innerRing = ["B2", "B3", "C3", "C2"];
        
        // ==================================================================================
        // DEBUG SYSTEM
        // ==================================================================================
        
        function debugLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${type.toUpperCase()}: ${message}`;
            
            console.log(logMessage);
            
            if (debugMode) {
                const debugLogElement = document.getElementById('debugLog');
                if (debugLogElement) {
                    debugLogElement.innerHTML += logMessage + '\n';
                    debugLogElement.scrollTop = debugLogElement.scrollHeight;
                }
            }
        }
        
        function toggleDebug() {
            debugMode = !debugMode;
            const debugSection = document.getElementById('debugSection');
            if (debugMode) {
                debugSection.style.display = 'block';
                debugLog('Debug-Modus aktiviert', 'debug');
            } else {
                debugSection.style.display = 'none';
            }
        }
        
        // ==================================================================================
        // SEITE 1: WEBRTC SETUP
        // ==================================================================================
        
        // Globale Variablen
        let isHttpsMode = false;
        
        function detectHostingMode() {
            isHttpsMode = window.location.protocol === 'https:' || window.location.protocol === 'http:';
            
            const hybridInfo = document.getElementById('hybridInfo');
            const hybridModeText = document.getElementById('hybridModeText');
            
            if (isHttpsMode) {
                document.getElementById('httpsMode').style.display = 'block';
                document.getElementById('codeInstructionHttps').style.display = 'list-item';
                hybridInfo.style.display = 'block';
                hybridModeText.textContent = 'Online-Hosting erkannt! Sie können Einladungslinks UND Codes verwenden.';
                debugLog('HTTPS-Modus erkannt - URLs und Codes verfügbar');
            } else {
                document.getElementById('fileMode').style.display = 'block';
                document.getElementById('fileModeWarning').style.display = 'block';
                document.getElementById('codeInstructionFile').style.display = 'list-item';
                hybridInfo.style.display = 'block';
                hybridModeText.textContent = 'Lokale Datei erkannt! Nur Code-System verfügbar (für URLs: Online hosten).';
                debugLog('Lokaler Datei-Modus - nur Codes verfügbar');
            }
        }
        
        function generateInviteCode() {
            // Erstelle 6-stelligen alphanumerischen Code
            const characters = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let gameCode = '';
            for (let i = 0; i < 6; i++) {
                gameCode += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            
            const stunServer = document.getElementById('stunServer').value;
            
            document.getElementById('gameCodeDisplay').textContent = gameCode;
            isHost = true;
            
            // Debug: Prüfe auf localStorage-Konflikte
            const existingOffer = localStorage.getItem(`game_offer_${gameCode}`);
            if (existingOffer) {
                debugLog('WARNUNG: Code bereits im localStorage - möglicherweise Tab-Konflikt!', 'warn');
            }
            
            // Speichere Game-Code für später
            sessionStorage.setItem('game_code', gameCode);
            sessionStorage.setItem('stun_server', stunServer);
            sessionStorage.setItem('is_host', 'true');
            
            // HTTPS-Modus: Generiere auch URL
            if (isHttpsMode) {
                const baseUrl = window.location.href.split('?')[0];
                const inviteUrl = `${baseUrl}?join=${gameCode}&stun=${encodeURIComponent(stunServer)}`;
                document.getElementById('inviteLink').textContent = inviteUrl;
                debugLog('Einladungs-URL generiert: ' + inviteUrl);
            }
            
            debugLog('Game Code generiert: ' + gameCode);
        }
        
        function copyInviteLink() {
            const link = document.getElementById('inviteLink').textContent;
            
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(link).then(() => {
                    showCopySuccess(event.target, '✅ Link kopiert!');
                }).catch(() => {
                    fallbackCopyToClipboard(link, event.target);
                });
            } else {
                fallbackCopyToClipboard(link, event.target);
            }
        }
        
        function copyGameCode() {
            const gameCode = document.getElementById('gameCodeDisplay').textContent;
            
            // Versuch 1: Moderne Clipboard API
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(gameCode).then(() => {
                    showCopySuccess(event.target, '✅ Code kopiert!');
                }).catch(() => {
                    fallbackCopyToClipboard(gameCode, event.target);
                });
            } else {
                // Fallback für lokale Dateien
                fallbackCopyToClipboard(gameCode, event.target);
            }
        }
        
        function fallbackCopyToClipboard(text, buttonElement) {
            // Erstelle temporäres Textfeld
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.top = '-9999px';
            textArea.style.left = '-9999px';
            document.body.appendChild(textArea);
            
            // Markiere und kopiere
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showCopySuccess(buttonElement, '✅ Kopiert!');
                } else {
                    showCopyFallback(text);
                }
            } catch (err) {
                showCopyFallback(text);
            }
            
            document.body.removeChild(textArea);
        }
        
        function showCopySuccess(buttonElement, message) {
            const originalText = buttonElement.textContent;
            buttonElement.textContent = message;
            buttonElement.style.background = 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)';
            
            setTimeout(() => {
                buttonElement.textContent = originalText;
                buttonElement.style.background = '';
            }, 2000);
        }
        
        function clearDebugData() {
            // Lösche alle localStorage-Einträge für Spiel
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && (key.startsWith('game_offer_') || 
                           key.startsWith('game_answer_') || 
                           key.startsWith('game_ice_'))) {
                    keysToRemove.push(key);
                }
            }
            
            keysToRemove.forEach(key => localStorage.removeItem(key));
            
            // Lösche auch sessionStorage
            sessionStorage.removeItem('game_code');
            sessionStorage.removeItem('stun_server');
            sessionStorage.removeItem('is_host');
            
            debugLog('Debug-Daten gelöscht: ' + keysToRemove.join(', '));
            
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '✅ Gelöscht!';
            
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        }
        
        function showCopyFallback(text) {
            // Markiere den Code automatisch zur manuellen Kopie
            const codeDisplay = document.getElementById('gameCodeDisplay');
            
            // Erstelle Selection
            const range = document.createRange();
            range.selectNodeContents(codeDisplay);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            
            // Zeige Hinweis
            alert(`Code wurde markiert: ${text}\n\nBitte drücken Sie Strg+C (oder Cmd+C auf Mac) zum Kopieren!`);
        }
        
        function goToPlayerSetup() {
            document.getElementById('setupPage').classList.remove('active');
            document.getElementById('playerPage').classList.add('active');
            
            // Host-Modus
            if (isHost) {
                // Host wartet erstmal - zeige entsprechende Nachricht
                document.getElementById('connectionStatus').style.display = 'none';
                document.getElementById('hostWaitingStatus').style.display = 'block';
                document.getElementById('codeJoinSection').style.display = 'none';
                initializeWebRTC();
            } else {
                // Für Joining Player - zeige Code-Eingabe
                showCodeJoinSection();
            }
        }
        
        function goToJoining() {
            isHost = false;
            document.getElementById('setupPage').classList.remove('active');
            document.getElementById('playerPage').classList.add('active');
            showCodeJoinSection();
        }
        
        function showCodeJoinSection() {
            document.getElementById('codeJoinSection').style.display = 'block';
            document.getElementById('connectionStatus').style.display = 'none';
            document.getElementById('gameCodeInput').focus();
        }
        
        function joinWithCode() {
            const gameCode = document.getElementById('gameCodeInput').value.trim().toUpperCase();
            const joinStatus = document.getElementById('joinStatus');
            
            if (!gameCode || gameCode.length !== 6) {
                joinStatus.style.display = 'block';
                joinStatus.className = 'status-message status-error';
                joinStatus.textContent = 'Bitte geben Sie einen 6-stelligen Code ein.';
                return;
            }
            
            // Validiere Code-Format
            const validChars = /^[ABCDEFGHJKLMNPQRSTUVWXYZ23456789]{6}$/;
            if (!validChars.test(gameCode)) {
                joinStatus.style.display = 'block';
                joinStatus.className = 'status-message status-error';
                joinStatus.textContent = 'Ungültiger Code-Format. Nur Buchstaben und Zahlen erlaubt.';
                return;
            }
            
            // Speichere Daten für WebRTC
            sessionStorage.setItem('game_code', gameCode);
            sessionStorage.setItem('stun_server', 'stun:stun.l.google.com:19302'); // Standard-Server
            sessionStorage.setItem('is_host', 'false');
            isHost = false;
            
            // Zeige Success und verstecke Code-Eingabe
            joinStatus.style.display = 'block';
            joinStatus.className = 'status-message status-success';
            joinStatus.textContent = `✅ Code ${gameCode} akzeptiert! Verbindung wird hergestellt...`;
            
            document.getElementById('codeJoinSection').style.display = 'none';
            document.getElementById('connectionStatus').style.display = 'block';
            
            // Starte WebRTC
            initializeWebRTC();
        }
        
        // ==================================================================================
        // SEITE 2: SPIELER SETUP
        // ==================================================================================
        
        function selectColor(color) {
            const blackOption = document.getElementById('blackOption');
            const whiteOption = document.getElementById('whiteOption');
            const colorStatus = document.getElementById('colorStatus');
            const playerName = document.getElementById('playerName');
            
            // Entferne vorherige Auswahl
            blackOption.classList.remove('selected');
            whiteOption.classList.remove('selected');
            
            // Prüfe ob Farbe bereits gewählt
            if (remotePlayerColor === color) {
                colorStatus.style.display = 'block';
                colorStatus.className = 'status-message status-error';
                colorStatus.textContent = `Diese Farbe wurde bereits von ${remotePlayerName || 'Ihrem Mitspieler'} gewählt.`;
                return;
            }
            
            // Setze neue Auswahl
            localPlayerColor = color;
            const selectedOption = color === 'black' ? blackOption : whiteOption;
            selectedOption.classList.add('selected');
            
            // Auto-Fill Name wenn leer
            if (!playerName.value.trim()) {
                playerName.value = color === 'black' ? 'Spieler Schwarz' : 'Spieler Weiss';
                playerName.select(); // Markiere Text zum Überschreiben
            }
            
            colorStatus.style.display = 'block';
            colorStatus.className = 'status-message status-success';
            colorStatus.textContent = `Sie spielen mit ${color === 'black' ? 'SCHWARZEN' : 'WEISSEN'} Kugeln.`;
            
            // Sende Farbwahl an anderen Spieler
            if (connectionEstablished) {
                sendMessage({
                    type: 'color_selection',
                    color: color,
                    name: playerName.value.trim() || (color === 'black' ? 'Spieler Schwarz' : 'Spieler Weiss')
                });
            }
            
            updateEnterGameButton();
        }
        
        function updateEnterGameButton() {
            const btn = document.getElementById('enterGameBtn');
            const nameInput = document.getElementById('playerName');
            
            btn.disabled = !localPlayerColor || !connectionEstablished || !nameInput.value.trim();
        }
        
        function enterGame() {
            localPlayerName = document.getElementById('playerName').value.trim();
            
            if (!localPlayerName) {
                alert('Bitte geben Sie einen Namen ein.');
                return;
            }
            
            // Sende finale Spieler-Info
            sendMessage({
                type: 'player_ready',
                name: localPlayerName,
                color: localPlayerColor
            });
            
            // Wechsle zur Spielseite
            document.getElementById('playerPage').classList.remove('active');
            document.getElementById('gamePage').classList.add('active');
            
            initializeGameBoard();
        }
        
        // ==================================================================================
        // WEBRTC IMPLEMENTIERUNG (KORRIGIERT)
        // ==================================================================================
        
        async function initializeWebRTC() {
            const stunServer = sessionStorage.getItem('stun_server');
            const gameCode = sessionStorage.getItem('game_code');
            isHost = sessionStorage.getItem('is_host') === 'true';
            
            debugLog(`WebRTC initialisiert: Code=${gameCode}, Host=${isHost}, Server=${stunServer}`);
            
            try {
                // RTCPeerConnection erstellen
                peerConnection = new RTCPeerConnection({
                    iceServers: [{ urls: stunServer }],
                    iceCandidatePoolSize: 10
                });
                
                // Event Listeners
                peerConnection.onicecandidate = handleIceCandidate;
                peerConnection.ondatachannel = handleDataChannel;
                peerConnection.onconnectionstatechange = handleConnectionStateChange;
                peerConnection.oniceconnectionstatechange = handleIceConnectionStateChange;
                
                if (isHost) {
                    await initializeAsHost(gameCode);
                } else {
                    await initializeAsGuest(gameCode);
                }
                
            } catch (error) {
                debugLog(`WebRTC Initialisierung fehlgeschlagen: ${error.message}`, 'error');
                showConnectionError('WebRTC Initialisierung fehlgeschlagen. Bitte anderen Server versuchen.');
            }
        }
        
        async function initializeAsHost(gameCode) {
            debugLog('Host-Initialisierung gestartet');
            
            // Host erstellt Data Channel
            dataChannel = peerConnection.createDataChannel('game-channel', {
                ordered: true
            });
            setupDataChannel();
            
            // Erstelle Offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            
            // Speichere Offer mit Game-Code
            const offerData = {
                offer: offer,
                timestamp: Date.now(),
                hostId: generateUniqueId()
            };
            
            localStorage.setItem(`game_offer_${gameCode}`, JSON.stringify(offerData));
            debugLog(`Host: Offer erstellt und gespeichert für Code ${gameCode}`);
            
            // Warte auf Answer
            waitForAnswer(gameCode);
        }
        
        async function initializeAsGuest(gameCode) {
            debugLog('Guest-Initialisierung gestartet');
            
            // Guest wartet auf Offer
            waitForOffer(gameCode);
        }
        
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }
        
        function setupDataChannel() {
            if (!dataChannel) return;
            
            dataChannel.onopen = () => {
                debugLog('Data Channel geöffnet');
                connectionEstablished = true;
                
                // Unterschiedliche Nachrichten für Host/Guest
                if (isHost) {
                    updateConnectionStatus('success', '🎉 Ihr Freund ist beigetreten! Verbindung hergestellt.');
                    document.getElementById('hostWaitingStatus').style.display = 'none';
                } else {
                    updateConnectionStatus('success', '🎉 Verbindung zum Host hergestellt!');
                }
                
                updateEnterGameButton();
            };
            
            dataChannel.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    debugLog(`Nachricht empfangen: ${message.type}`);
                    handleMessage(message);
                } catch (error) {
                    debugLog(`Fehler beim Parsen der Nachricht: ${error.message}`, 'error');
                }
            };
            
            dataChannel.onerror = (error) => {
                debugLog(`Data Channel Fehler: ${error}`, 'error');
                showConnectionError('Verbindungsfehler. Versuchen Sie einen anderen Server.');
            };
            
            dataChannel.onclose = () => {
                debugLog('Data Channel geschlossen', 'warn');
                connectionEstablished = false;
            };
        }
        
        function handleDataChannel(event) {
            debugLog('Data Channel vom Remote empfangen');
            dataChannel = event.channel;
            setupDataChannel();
        }
        
        function handleIceCandidate(event) {
            if (event.candidate) {
                const gameCode = sessionStorage.getItem('game_code');
                const myId = isHost ? 'host' : 'guest';
                
                debugLog(`ICE Candidate generiert (${myId})`);
                
                // Lade bestehende Candidates
                const candidates = JSON.parse(localStorage.getItem(`game_ice_${gameCode}`) || '[]');
                
                // Füge neuen Candidate hinzu
                const candidateData = {
                    candidate: event.candidate,
                    from: myId,
                    timestamp: Date.now(),
                    id: generateUniqueId()
                };
                
                candidates.push(candidateData);
                localStorage.setItem(`game_ice_${gameCode}`, JSON.stringify(candidates));
                
                // Füge zu lokaler Liste hinzu
                iceCandidatesSent.push(candidateData.id);
            }
        }
        
        function handleConnectionStateChange() {
            debugLog(`Connection State: ${peerConnection.connectionState}`);
            
            if (peerConnection.connectionState === 'connected') {
                updateConnectionStatus('success', 'Verbindung aktiv! 🎉');
                debugLog('WebRTC Verbindung erfolgreich hergestellt');
            } else if (peerConnection.connectionState === 'disconnected') {
                debugLog('Verbindung unterbrochen', 'warn');
                showConnectionError('Verbindung unterbrochen. Seite neu laden und erneut versuchen.');
            } else if (peerConnection.connectionState === 'failed') {
                debugLog('Verbindung fehlgeschlagen', 'error');
                handleConnectionFailure();
            }
        }
        
        function handleIceConnectionStateChange() {
            debugLog(`ICE Connection State: ${peerConnection.iceConnectionState}`);
            
            if (peerConnection.iceConnectionState === 'failed') {
                debugLog('ICE Verbindung fehlgeschlagen - versuche Neustart', 'error');
                // ICE Restart könnte hier implementiert werden
            }
        }
        
        function handleConnectionFailure() {
            connectionAttempts++;
            
            if (connectionAttempts < maxConnectionAttempts) {
                debugLog(`Verbindungsversuch ${connectionAttempts}/${maxConnectionAttempts} fehlgeschlagen - versuche erneut`, 'warn');
                
                setTimeout(() => {
                    initializeWebRTC();
                }, 2000);
            } else {
                debugLog('Maximale Anzahl Verbindungsversuche erreicht', 'error');
                showConnectionError('Verbindung fehlgeschlagen nach mehreren Versuchen. Bitte andere Server oder Browser versuchen.');
            }
        }
        
        async function waitForOffer(gameCode) {
            debugLog(`Guest wartet auf Offer für Code: ${gameCode}`);
            
            let attempts = 0;
            const maxAttempts = 30; // 30 Sekunden
            
            const checkOffer = async () => {
                attempts++;
                
                const offerData = localStorage.getItem(`game_offer_${gameCode}`);
                if (offerData) {
                    try {
                        debugLog('Guest: Offer gefunden');
                        const { offer } = JSON.parse(offerData);
                        
                        await peerConnection.setRemoteDescription(offer);
                        debugLog('Guest: Remote Description gesetzt');
                        
                        // Erstelle Answer
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        debugLog('Guest: Answer erstellt');
                        
                        // Speichere Answer
                        const answerData = {
                            answer: answer,
                            timestamp: Date.now(),
                            guestId: generateUniqueId()
                        };
                        
                        localStorage.setItem(`game_answer_${gameCode}`, JSON.stringify(answerData));
                        debugLog('Guest: Answer gespeichert');
                        
                        // Verarbeite ICE Candidates
                        startIceCandidateProcessing(gameCode);
                        
                    } catch (error) {
                        debugLog(`Guest: Fehler beim Verarbeiten des Offers: ${error.message}`, 'error');
                        showConnectionError('Fehler beim Beitreten. Bitte erneut versuchen.');
                    }
                } else if (attempts < maxAttempts) {
                    setTimeout(checkOffer, 1000);
                } else {
                    debugLog('Guest: Timeout beim Warten auf Offer', 'error');
                    showConnectionError('Host nicht gefunden. Code prüfen oder Host bitten, Code neu zu generieren.');
                }
            };
            
            checkOffer();
        }
        
        async function waitForAnswer(gameCode) {
            debugLog(`Host wartet auf Answer für Code: ${gameCode}`);
            
            let attempts = 0;
            const maxAttempts = 60; // 60 Sekunden für Host
            
            const checkAnswer = async () => {
                attempts++;
                
                const answerData = localStorage.getItem(`game_answer_${gameCode}`);
                if (answerData) {
                    try {
                        debugLog('Host: Answer gefunden');
                        const { answer } = JSON.parse(answerData);
                        await peerConnection.setRemoteDescription(answer);
                        debugLog('Host: Remote Description (Answer) gesetzt');
                        
                        // Verarbeite ICE Candidates
                        startIceCandidateProcessing(gameCode);
                        
                    } catch (error) {
                        debugLog(`Host: Fehler beim Verarbeiten der Answer: ${error.message}`, 'error');
                        showConnectionError('Fehler bei der Verbindung. Bitte erneut versuchen.');
                    }
                } else if (attempts < maxAttempts) {
                    setTimeout(checkAnswer, 1000);
                } else {
                    debugLog('Host: Timeout beim Warten auf Answer', 'error');
                    showConnectionError('Kein Gast beigetreten. Code mit Freund teilen.');
                }
            };
            
            checkAnswer();
        }
        
        function startIceCandidateProcessing(gameCode) {
            debugLog('ICE Candidate Processing gestartet');
            
            const myRole = isHost ? 'host' : 'guest';
            const otherRole = isHost ? 'guest' : 'host';
            
            const processInterval = setInterval(() => {
                if (peerConnection.connectionState === 'connected') {
                    debugLog('Verbindung hergestellt - ICE Processing beendet');
                    clearInterval(processInterval);
                    return;
                }
                
                const candidates = JSON.parse(localStorage.getItem(`game_ice_${gameCode}`) || '[]');
                
                candidates.forEach(async (item) => {
                    // Nur Candidates vom anderen Peer verarbeiten
                    if (item.from === otherRole && !iceCandidatesReceived.includes(item.id)) {
                        try {
                            await peerConnection.addIceCandidate(item.candidate);
                            iceCandidatesReceived.push(item.id);
                            debugLog(`ICE Candidate von ${otherRole} hinzugefügt`);
                        } catch (error) {
                            debugLog(`ICE Candidate Fehler: ${error.message}`, 'warn');
                        }
                    }
                });
                
            }, 500); // Häufigere Prüfung für bessere Verbindung
            
            // Timeout nach 30 Sekunden
            setTimeout(() => {
                if (peerConnection.connectionState !== 'connected') {
                    clearInterval(processInterval);
                    debugLog('ICE Processing Timeout', 'warn');
                }
            }, 30000);
        }
        
        function sendMessage(message) {
            if (dataChannel && dataChannel.readyState === 'open') {
                try {
                    dataChannel.send(JSON.stringify(message));
                    debugLog(`Nachricht gesendet: ${message.type}`);
                } catch (error) {
                    debugLog(`Fehler beim Senden: ${error.message}`, 'error');
                }
            } else {
                debugLog(`Nachricht nicht gesendet - Channel State: ${dataChannel?.readyState}`, 'warn');
            }
        }
        
        function handleMessage(message) {
            debugLog(`Nachricht empfangen: ${message.type}`);
            
            switch (message.type) {
                case 'color_selection':
                    handleRemoteColorSelection(message.color, message.name);
                    break;
                    
                case 'player_ready':
                    handleRemotePlayerReady(message.name, message.color);
                    break;
                    
                case 'game_move':
                    handleGameMove(message);
                    break;
                    
                case 'chat_message':
                    handleChatMessage(message.text, message.sender);
                    break;
                    
                case 'game_start':
                    startGame();
                    break;
                    
                default:
                    debugLog(`Unbekannter Nachrichten-Typ: ${message.type}`, 'warn');
            }
        }
        
        function handleRemoteColorSelection(color, name) {
            remotePlayerColor = color;
            remotePlayerName = name;
            
            debugLog(`Remote Spieler wählte: ${color} (${name})`);
            
            // Blockiere diese Farbe für lokalen Spieler
            const colorOption = document.getElementById(color === 'black' ? 'blackOption' : 'whiteOption');
            colorOption.classList.add('disabled');
            
            // Zeige Warnung wenn lokaler Spieler dieselbe Farbe gewählt hat
            if (localPlayerColor === color) {
                const colorStatus = document.getElementById('colorStatus');
                colorStatus.style.display = 'block';
                colorStatus.className = 'status-message status-error';
                colorStatus.textContent = `Diese Farbe wurde bereits von ${name} gewählt.`;
                
                // Entferne lokale Auswahl
                localPlayerColor = null;
                document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
            }
            
            updateEnterGameButton();
        }
        
        function handleRemotePlayerReady(name, color) {
            remotePlayerName = name;
            remotePlayerColor = color;
            remotePeerReady = true;
            
            debugLog(`Remote Spieler bereit: ${name} (${color})`);
            
            updateGameUI();
            
            // Wenn beide bereit sind, starte das Spiel
            if (localPeerReady) {
                sendMessage({ type: 'game_start' });
                startGame();
            }
        }
        
        function updateConnectionStatus(type, text) {
            const status = document.getElementById('connectionStatus');
            status.className = `status-message status-${type}`;
            status.innerHTML = text;
        }
        
        function showConnectionError(message) {
            updateConnectionStatus('error', `❌ ${message}`);
        }
        
        // ==================================================================================
        // SEITE 3: SPIELLOGIK (bleibt unverändert)
        // ==================================================================================
        
        function initializeGameBoard() {
            localPeerReady = true;
            
            const board = document.getElementById('orbitoBoard');
            
            // Erstelle Spielfelder
            const positions = [
                'A1', 'B1', 'C1', 'D1',
                'A2', 'B2', 'C2', 'D2', 
                'A3', 'B3', 'C3', 'D3',
                'A4', 'B4', 'C4', 'D4'
            ];
            
            positions.forEach(pos => {
                const field = document.createElement('div');
                field.className = 'field';
                field.id = pos;
                field.innerHTML = `<span class="field-label">${pos}</span>`;
                
                // Ring-Markierung
                if (outerRing.includes(pos)) {
                    field.classList.add('outer-ring');
                } else if (innerRing.includes(pos)) {
                    field.classList.add('inner-ring');
                }
                
                // Event Listeners für Touch/Drag
                field.addEventListener('touchstart', handleFieldTouch);
                field.addEventListener('touchmove', handleFieldTouchMove);
                field.addEventListener('touchend', handleFieldTouchEnd);
                field.addEventListener('click', handleFieldClick);
                
                // Drag & Drop Events
                field.addEventListener('dragover', handleDragOver);
                field.addEventListener('drop', handleDrop);
                
                board.appendChild(field);
            });
            
            // Erstelle Kugelvorräte
            createBallStorage();
            updateGameUI();
        }
        
        function createBallStorage() {
            const localStorage = document.getElementById('ballStorage');
            const opponentStorage = document.getElementById('opponentStorage');
            
            // Lokale Kugeln (8 Stück)
            for (let i = 0; i < 8; i++) {
                const ball = document.createElement('div');
                ball.className = `storage-ball ball ${localPlayerColor}`;
                ball.textContent = localPlayerColor === 'black' ? '⚫' : '⚪';
                ball.draggable = true;
                ball.dataset.ballId = `local_${i}`;
                
                // Drag Events
                ball.addEventListener('dragstart', handleDragStart);
                ball.addEventListener('touchstart', handleTouchStart);
                ball.addEventListener('touchmove', handleTouchMove);
                ball.addEventListener('touchend', handleTouchEnd);
                
                localStorage.appendChild(ball);
            }
            
            // Gegner-Kugeln (zur Anzeige)
            const opponentColor = localPlayerColor === 'black' ? 'white' : 'black';
            for (let i = 0; i < 8; i++) {
                const ball = document.createElement('div');
                ball.className = `storage-ball ball ${opponentColor}`;
                ball.textContent = opponentColor === 'black' ? '⚫' : '⚪';
                ball.style.opacity = '0.5';
                ball.dataset.ballId = `opponent_${i}`;
                
                opponentStorage.appendChild(ball);
            }
        }
        
        function updateGameUI() {
            // Spieler-Info aktualisieren
            const player1Info = document.getElementById('player1Info');
            const player2Info = document.getElementById('player2Info');
            
            if (localPlayerColor === 'black') {
                player1Info.querySelector('span').textContent = localPlayerName;
                player2Info.querySelector('span').textContent = remotePlayerName || 'Warten...';
                player2Info.querySelector('.player-color').textContent = '⚪';
            } else {
                player1Info.querySelector('span').textContent = remotePlayerName || 'Warten...';
                player1Info.querySelector('.player-color').textContent = '⚫';
                player2Info.querySelector('span').textContent = localPlayerName;
                player2Info.querySelector('.player-color').textContent = '⚪';
            }
            
            updateTurnIndicator();
        }
        
        function updateTurnIndicator() {
            const player1Info = document.getElementById('player1Info');
            const player2Info = document.getElementById('player2Info');
            
            player1Info.classList.remove('active');
            player2Info.classList.remove('active');
            
            if (currentPlayer === 'black') {
                if (localPlayerColor === 'black') {
                    player1Info.classList.add('active');
                } else {
                    player1Info.classList.add('active');
                }
            } else {
                if (localPlayerColor === 'white') {
                    player2Info.classList.add('active');
                } else {
                    player2Info.classList.add('active');
                }
            }
        }
        
        function startGame() {
            gamePhase = 'playing';
            startNewMove(); // Beginne ersten Zug
            updateGameStatus('Spiel gestartet! Schwarz beginnt.');
            updateTurnIndicator();
            
            // Orbito-Button aktivieren wenn lokaler Spieler am Zug
            if (currentPlayer === localPlayerColor && moveStep === 'orbito') {
                document.getElementById('orbitoButton').classList.remove('disabled');
                document.getElementById('orbitoButton').classList.add('active');
            }
            
            debugLog('Spiel gestartet');
        }
        
        function updateGameStatus(message) {
            document.getElementById('gameStatus').textContent = message;
        }
        
        // ==================================================================================
        // DRAG & DROP / TOUCH HANDLING (bleibt unverändert)
        // ==================================================================================
        
        function handleDragStart(event) {
            if (currentPlayer !== localPlayerColor || moveStep !== 'platzieren') {
                event.preventDefault();
                return;
            }
            
            dragElement = event.target;
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/html', event.target.outerHTML);
        }
        
        function handleTouchStart(event) {
            if (currentPlayer !== localPlayerColor) return;
            
            event.preventDefault();
            const touch = event.touches[0];
            const element = event.target;
            
            if (element.classList.contains('storage-ball') && moveStep === 'platzieren') {
                // Drag-Modus für Kugelplatzierung
                startDrag(element, touch);
            } else if (element.classList.contains('ball') && moveStep === 'umsetzen') {
                // Kugel für Umsetzen auswählen
                selectBallForMove(element);
            }
        }
        
        function startDrag(element, touch) {
            isDragging = true;
            dragElement = element.cloneNode(true);
            dragElement.classList.add('dragging');
            dragElement.style.position = 'fixed';
            dragElement.style.zIndex = '1000';
            dragElement.style.pointerEvents = 'none';
            
            document.body.appendChild(dragElement);
            
            const rect = element.getBoundingClientRect();
            dragOffset.x = touch.clientX - rect.left;
            dragOffset.y = touch.clientY - rect.top;
            
            updateDragPosition(touch);
        }
        
        function handleTouchMove(event) {
            if (!isDragging) return;
            
            event.preventDefault();
            const touch = event.touches[0];
            updateDragPosition(touch);
            
            // Magnetismus-Effekt
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            updateMagnetism(elementBelow);
        }
        
        function updateDragPosition(touch) {
            if (dragElement) {
                dragElement.style.left = (touch.clientX - dragOffset.x) + 'px';
                dragElement.style.top = (touch.clientY - dragOffset.y) + 'px';
            }
        }
        
        function updateMagnetism(elementBelow) {
            // Entferne vorherige Magnetismus-Effekte
            document.querySelectorAll('.field').forEach(field => {
                field.classList.remove('magnetic');
            });
            
            // Prüfe ob über gültigem Feld
            const field = elementBelow?.closest('.field');
            if (field && isValidMove(field.id)) {
                field.classList.add('magnetic');
            }
        }
        
        function handleTouchEnd(event) {
            if (!isDragging) return;
            
            event.preventDefault();
            const touch = event.changedTouches[0];
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            const field = elementBelow?.closest('.field');
            
            // Cleanup
            if (dragElement && dragElement.parentNode) {
                dragElement.parentNode.removeChild(dragElement);
            }
            
            document.querySelectorAll('.field').forEach(f => {
                f.classList.remove('magnetic');
            });
            
            isDragging = false;
            dragElement = null;
            
            // Verarbeite Drop
            if (field && isValidMove(field.id)) {
                handleBallPlacement(field.id);
            }
        }
        
        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
        }
        
        function handleDrop(event) {
            event.preventDefault();
            const field = event.target.closest('.field');
            
            if (field && isValidMove(field.id)) {
                handleBallPlacement(field.id);
            }
        }
        
        function handleFieldClick(event) {
            const field = event.target.closest('.field');
            const position = field.id;
            
            if (confirmNeeded === position) {
                // Bestätigung für platzierte Kugel
                confirmBallPlacement(position);
            } else if (moveStep === 'umsetzen' && gameBoard[position]) {
                // Gegnerische Kugel für Umsetzen auswählen
                if (gameBoard[position] !== localPlayerColor) {
                    selectBallForMove(field.querySelector('.ball'));
                }
            }
        }
        
        function handleFieldTouch(event) {
            // Touch-spezifische Behandlung falls nötig
        }
        
        function handleFieldTouchMove(event) {
            // Touch-Move-spezifische Behandlung falls nötig
        }
        
        function handleFieldTouchEnd(event) {
            // Touch-End-spezifische Behandlung falls nötig
        }
        
        // ==================================================================================
        // SPIELZUG-LOGIK (bleibt unverändert)
        // ==================================================================================
        
        function isValidMove(position) {
            if (moveStep === 'platzieren') {
                return !gameBoard[position]; // Leeres Feld
            } else if (moveStep === 'umsetzen' && selectedBall) {
                // Prüfe ob erlaubtes Nachbarfeld
                const currentPos = selectedBall.closest('.field').id;
                return isNeighbor(currentPos, position) && !gameBoard[position];
            }
            return false;
        }
        
        function isNeighbor(pos1, pos2) {
            const col1 = pos1.charCodeAt(0) - 65; // A=0, B=1, etc.
            const row1 = parseInt(pos1[1]) - 1;   // 1=0, 2=1, etc.
            const col2 = pos2.charCodeAt(0) - 65;
            const row2 = parseInt(pos2[1]) - 1;
            
            const colDiff = Math.abs(col1 - col2);
            const rowDiff = Math.abs(row1 - row2);
            
            return (colDiff === 1 && rowDiff === 0) || (colDiff === 0 && rowDiff === 1);
        }
        
        function selectBallForMove(ballElement) {
            if (currentPlayer !== localPlayerColor || moveStep !== 'umsetzen') return;
            
            const position = ballElement.closest('.field').id;
            const ballColor = gameBoard[position];
            
            // Nur gegnerische Kugeln können umgesetzt werden
            if (ballColor === localPlayerColor) return;
            
            // Entferne vorherige Auswahl
            document.querySelectorAll('.ball').forEach(ball => {
                ball.classList.remove('selected');
            });
            
            document.querySelectorAll('.field').forEach(field => {
                field.classList.remove('valid-move');
            });
            
            // Neue Auswahl
            selectedBall = ballElement;
            ballElement.classList.add('selected');
            
            // Zeige gültige Zielfelder
            const neighbors = getNeighbors(position);
            neighbors.forEach(neighborPos => {
                if (!gameBoard[neighborPos]) {
                    document.getElementById(neighborPos).classList.add('valid-move');
                }
            });
            
            updateGameStatus(`Gegnerische ${ballColor === 'black' ? 'schwarze' : 'weiße'} Kugel ausgewählt. Wählen Sie ein angrenzendes Feld.`);
        }
        
        function getNeighbors(position) {
            const col = position.charCodeAt(0) - 65;
            const row = parseInt(position[1]) - 1;
            const neighbors = [];
            
            // Prüfe alle 4 Richtungen
            if (row > 0) neighbors.push(String.fromCharCode(65 + col) + row);          // Oben
            if (row < 3) neighbors.push(String.fromCharCode(65 + col) + (row + 2));    // Unten
            if (col > 0) neighbors.push(String.fromCharCode(64 + col) + (row + 1));    // Links
            if (col < 3) neighbors.push(String.fromCharCode(66 + col) + (row + 1));    // Rechts
            
            return neighbors;
        }
        
        function handleBallPlacement(position) {
            if (moveStep === 'platzieren') {
                // Eigene Kugel platzieren
                placeBall(position, localPlayerColor);
                
                // Für Export aufzeichnen
                if (currentMove) {
                    currentMove.position = position;
                }
                
                confirmNeeded = position;
                
                // Zeige Bestätigungs-Animation
                const field = document.getElementById(position);
                const ball = field.querySelector('.ball');
                if (ball) {
                    ball.classList.add('confirm-needed');
                }
                
                updateGameStatus('Kugel platziert. Tippen Sie nochmal auf die Kugel zur Bestätigung.');
                
            } else if (moveStep === 'umsetzen' && selectedBall) {
                // Gegnerische Kugel umsetzen
                const fromPosition = selectedBall.closest('.field').id;
                moveBall(fromPosition, position);
                
                // Für Export aufzeichnen
                if (currentMove) {
                    currentMove.umsetzen = {
                        from: fromPosition,
                        to: position
                    };
                }
                
                // Cleanup
                selectedBall.classList.remove('selected');
                selectedBall = null;
                document.querySelectorAll('.field').forEach(field => {
                    field.classList.remove('valid-move');
                });
                
                confirmNeeded = position;
                updateGameStatus('Kugel umgesetzt. Tippen Sie nochmal zur Bestätigung.');
            }
        }
        
        function confirmBallPlacement(position) {
            if (confirmNeeded !== position) return;
            
            confirmNeeded = null;
            
            // Entferne Bestätigungs-Animation
            const field = document.getElementById(position);
            const ball = field.querySelector('.ball');
            if (ball) {
                ball.classList.remove('confirm-needed');
            }
            
            // Nächster Schritt
            if (moveStep === 'umsetzen') {
                moveStep = 'platzieren';
                updateGameStatus('Jetzt eigene Kugel platzieren.');
            } else if (moveStep === 'platzieren') {
                moveStep = 'orbito';
                updateGameStatus('Jetzt Dreh-Button drücken!');
                document.getElementById('orbitoButton').classList.remove('disabled');
                document.getElementById('orbitoButton').classList.add('active');
            }
        }
        
        function placeBall(position, color) {
            const field = document.getElementById(position);
            
            // Entferne existierende Kugel
            const existingBall = field.querySelector('.ball');
            if (existingBall) {
                existingBall.remove();
            }
            
            // Erstelle neue Kugel
            const ball = document.createElement('div');
            ball.className = `ball ${color}`;
            ball.textContent = color === 'black' ? '⚫' : '⚪';
            ball.addEventListener('click', handleFieldClick);
            
            field.appendChild(ball);
            gameBoard[position] = color;
            
            // Entferne Kugel aus Vorrat
            if (color === localPlayerColor) {
                const storageBall = document.querySelector(`#ballStorage .storage-ball:not([style*="display: none"])`);
                if (storageBall) {
                    storageBall.style.display = 'none';
                }
                ballsPlaced++;
            }
        }
        
        function moveBall(fromPosition, toPosition) {
            const color = gameBoard[fromPosition];
            
            // Entferne von alter Position
            const fromField = document.getElementById(fromPosition);
            const ball = fromField.querySelector('.ball');
            if (ball) {
                ball.remove();
            }
            delete gameBoard[fromPosition];
            
            // Setze auf neue Position
            placeBall(toPosition, color);
        }
        
        function executeOrbito() {
            if (currentPlayer !== localPlayerColor || moveStep !== 'orbito') return;
            
            // Dreh-Animation
            const button = document.getElementById('orbitoButton');
            button.classList.remove('active');
            button.classList.add('disabled');
            
            // Führe Dreh-Rotation aus
            performOrbitoRotation();
            
            // Sende Zug an Gegner
            const gameMove = {
                type: 'game_move',
                action: 'orbito',
                gameState: { ...gameBoard },
                player: localPlayerColor
            };
            
            sendMessage(gameMove);
            
            // Prüfe Gewinnbedingung
            setTimeout(() => {
                const winner = checkWinningCondition();
                if (winner) {
                    endGame(winner);
                } else if (ballsPlaced >= 16) {
                    // Endspiel-Mechanik
                    startEndgame();
                } else {
                    // Nächster Spieler
                    switchPlayer();
                }
            }, 1000);
        }
        
        function performOrbitoRotation() {
            const newBoard = {};
            
            // Rotiere alle Kugeln
            for (const position in gameBoard) {
                const color = gameBoard[position];
                const newPosition = getNextPosition(position);
                newBoard[newPosition] = color;
            }
            
            // Aktualisiere Board
            gameBoard = newBoard;
            updateBoardDisplay();
        }
        
        function getNextPosition(position) {
            if (outerRing.includes(position)) {
                const currentIndex = outerRing.indexOf(position);
                const nextIndex = (currentIndex + 1) % outerRing.length;
                return outerRing[nextIndex];
            } else if (innerRing.includes(position)) {
                const currentIndex = innerRing.indexOf(position);
                const nextIndex = (currentIndex + 1) % innerRing.length;
                return innerRing[nextIndex];
            }
            return position;
        }
        
        function updateBoardDisplay() {
            // Lösche alle Kugeln
            document.querySelectorAll('.field .ball').forEach(ball => ball.remove());
            
            // Platziere Kugeln an neuen Positionen
            for (const position in gameBoard) {
                const color = gameBoard[position];
                const field = document.getElementById(position);
                
                const ball = document.createElement('div');
                ball.className = `ball ${color}`;
                ball.textContent = color === 'black' ? '⚫' : '⚪';
                ball.addEventListener('click', handleFieldClick);
                
                field.appendChild(ball);
            }
        }
        
        function startNewMove() {
            currentMove = {
                player: currentPlayer,
                umsetzen: null,
                position: null
            };
        }
        
        function finishMove() {
            if (currentMove && currentMove.position) {
                gameMoves.push(currentMove);
                debugLog(`Zug aufgezeichnet: ${JSON.stringify(currentMove)}`);
            }
            currentMove = null;
        }
        
        function switchPlayer() {
            finishMove(); // Beende aktuellen Zug
            
            currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
            moveStep = ballsPlaced >= 2 ? 'umsetzen' : 'platzieren'; // Ab dem 2. Zug kann umgesetzt werden
            
            startNewMove(); // Beginne neuen Zug
            updateTurnIndicator();
            
            if (currentPlayer === localPlayerColor) {
                updateGameStatus(`Sie sind am Zug! ${moveStep === 'umsetzen' ? 'Gegnerische Kugel umsetzen (optional)' : 'Eigene Kugel platzieren'}`);
            } else {
                updateGameStatus(`${remotePlayerName} ist am Zug...`);
            }
        }
        
        function handleGameMove(message) {
            // Behandle erhaltenen Spielzug vom Gegner
            debugLog(`Spielzug empfangen: ${message.action}`);
            
            if (message.action === 'orbito') {
                gameBoard = message.gameState;
                updateBoardDisplay();
                
                // Prüfe Gewinnbedingung
                const winner = checkWinningCondition();
                if (winner) {
                    endGame(winner);
                } else if (ballsPlaced >= 16) {
                    startEndgame();
                } else {
                    switchPlayer();
                }
            }
        }
        
        function checkWinningCondition() {
            const lines = [
                // Horizontal
                ['A1', 'B1', 'C1', 'D1'],
                ['A2', 'B2', 'C2', 'D2'],
                ['A3', 'B3', 'C3', 'D3'],
                ['A4', 'B4', 'C4', 'D4'],
                // Vertikal
                ['A1', 'A2', 'A3', 'A4'],
                ['B1', 'B2', 'B3', 'B4'],
                ['C1', 'C2', 'C3', 'C4'],
                ['D1', 'D2', 'D3', 'D4'],
                // Diagonal
                ['A1', 'B2', 'C3', 'D4'],
                ['D1', 'C2', 'B3', 'A4']
            ];
            
            for (const line of lines) {
                const colors = line.map(pos => gameBoard[pos]).filter(Boolean);
                if (colors.length === 4 && colors.every(color => color === colors[0])) {
                    // Gewinnlinie gefunden
                    highlightWinningLine(line);
                    return colors[0];
                }
            }
            
            return null;
        }
        
        function highlightWinningLine(line) {
            line.forEach(position => {
                const field = document.getElementById(position);
                field.classList.add('winning-line');
            });
        }
        
        function endGame(winner) {
            gameWon = true;
            gamePhase = 'finished';
            
            const winnerName = winner === localPlayerColor ? 'Sie haben' : `${remotePlayerName} hat`;
            updateGameStatus(`🎉 ${winnerName} gewonnen!`);
            
            debugLog(`Spiel beendet - Gewinner: ${winner}`);
            
            // Exportiere Partie für Simulator
            exportGameForSimulator(winner);
        }
        
        function startEndgame() {
            updateGameStatus('Alle 16 Kugeln platziert! Endspiel-Mechanik startet...');
            
            setTimeout(() => {
                performEndgameRotation();
            }, 2000);
        }
        
        function performEndgameRotation() {
            if (endgameRotations >= 5) {
                endGame(null); // Unentschieden
                return;
            }
            
            endgameRotations++;
            performOrbitoRotation();
            
            const winner = checkWinningCondition();
            if (winner) {
                endGame(winner);
            } else {
                setTimeout(() => {
                    performEndgameRotation();
                }, 1500);
            }
        }
        
        // ==================================================================================
        // CHAT SYSTEM (bleibt unverändert)
        // ==================================================================================
        
        function toggleChat() {
            chatOpen = !chatOpen;
            const chatContainer = document.getElementById('chatContainer');
            
            if (chatOpen) {
                chatContainer.classList.add('open');
                document.getElementById('chatInput').focus();
                
                // Reset unread counter
                unreadMessages = 0;
                updateChatNotification();
            } else {
                chatContainer.classList.remove('open');
            }
        }
        
        function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Lokale Anzeige
            addChatMessage(message, localPlayerName, true);
            
            // An Gegner senden
            sendMessage({
                type: 'chat_message',
                text: message,
                sender: localPlayerName
            });
            
            input.value = '';
        }
        
        function handleChatMessage(text, sender) {
            addChatMessage(text, sender, false);
            
            // Unread counter wenn Chat geschlossen
            if (!chatOpen) {
                unreadMessages++;
                updateChatNotification();
                
                // Auto-öffne Chat kurz
                const chatContainer = document.getElementById('chatContainer');
                chatContainer.classList.add('open');
                setTimeout(() => {
                    if (!chatOpen) {
                        chatContainer.classList.remove('open');
                    }
                }, 3000);
            }
        }
        
        function addChatMessage(text, sender, isLocal) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';
            
            const time = new Date().toLocaleTimeString('de-DE', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            messageDiv.innerHTML = `
                <strong>${sender}</strong> <small>(${time})</small><br>
                ${escapeHtml(text)}
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        function updateChatNotification() {
            const notification = document.getElementById('chatNotification');
            if (unreadMessages > 0) {
                notification.style.display = 'flex';
                notification.textContent = unreadMessages;
            } else {
                notification.style.display = 'none';
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // ==================================================================================
        // SIMULATOR EXPORT (bleibt unverändert)
        // ==================================================================================
        
        function exportGameForSimulator(winner) {
            finishMove(); // Stelle sicher, dass letzter Zug gespeichert ist
            
            const winLine = winner ? findWinningLine() : null;
            const timestamp = new Date().toISOString().split('T')[0];
            
            // Bestimme Dateiname basierend auf Gewinnlinie
            const fileName = determineExportFileName(winLine);
            
            // Generiere eindeutige Key
            const randomNumber = Math.floor(Math.random() * 9000000000) + 1000000000;
            const strategyKey = generateStrategyKey(winLine, !winner, randomNumber);
            
            const gameData = {
                key: strategyKey,
                name: `Online: ${localPlayerName} vs ${remotePlayerName}`,
                winLine: winLine,
                moves: gameMoves, // Korrekte Moves-Struktur
                description: `Live gespielt am ${timestamp}`,
                theory: `Online-Partie zwischen echten Spielern`,
                verified: true
            };
            
            // Füge result-Feld für Unentschieden hinzu
            if (!winner) {
                gameData.result = 'draw';
            }
            
            // JSONL-Format (eine Zeile)
            const jsonlLine = JSON.stringify(gameData);
            
            // Download als JSONL-Zeile
            const blob = new Blob([jsonlLine], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Benutzer informieren
            const fileType = fileName.replace('_export.jsonl', '.json');
            updateGameStatus(`🎉 Partie beendet! JSONL-Zeile für "${fileName}" erstellt.`);
            
            // Zusätzliche Anweisungen für Benutzer
            setTimeout(() => {
                alert(`📁 Export erfolgreich!\n\n` +
                      `✅ Datei heruntergeladen: ${fileName}\n\n` +
                      `📋 So verwenden Sie den Export:\n` +
                      `1. Öffnen Sie die entsprechende Simulator-Datei: ${fileType}\n` +
                      `2. Kopieren Sie die heruntergeladene JSONL-Zeile\n` +
                      `3. Fügen Sie die Zeile am Ende der ${fileType} Datei hinzu\n` +
                      `4. Speichern Sie die Datei\n` +
                      `5. Laden Sie den Simulator neu\n\n` +
                      `🎯 Ihre Partie ist jetzt im Simulator abspielbar!`);
            }, 1000);
            
            // Console-Log für Debugging
            debugLog(`EXPORT FÜR SIMULATOR - Datei: ${fileName}, JSONL: ${jsonlLine}`);
        }
        
        function determineExportFileName(winLine) {
            if (!winLine) {
                return 'draw_export.jsonl';
            }
            
            const line = JSON.stringify(winLine);
            
            // Horizontal
            if (line === '["A1","B1","C1","D1"]' || line === '["A2","B2","C2","D2"]' || 
                line === '["A3","B3","C3","D3"]' || line === '["A4","B4","C4","D4"]') {
                return 'horizontal_export.jsonl';
            }
            
            // Vertikal
            if (line === '["A1","A2","A3","A4"]' || line === '["B1","B2","B3","B4"]' ||
                line === '["C1","C2","C3","C4"]' || line === '["D1","D2","D3","D4"]') {
                return 'vertical_export.jsonl';
            }
            
            // Diagonal
            if (line === '["A1","B2","C3","D4"]') {
                return 'diagonal-main_export.jsonl';
            }
            
            if (line === '["D1","C2","B3","A4"]') {
                return 'diagonal-anti_export.jsonl';
            }
            
            return 'unknown_export.jsonl';
        }
        
        function generateStrategyKey(winLine, isDraw, randomNumber) {
            if (isDraw || !winLine) {
                return `draw_game_${randomNumber}`;
            }
            
            const lineType = getLineTypeFromWinLine(winLine);
            const lineIdentifier = getLineIdentifier(winLine);
            
            return `${lineType}_${lineIdentifier}_${randomNumber}`;
        }
        
        function getLineTypeFromWinLine(winLine) {
            if (!winLine) return 'draw';
            
            const line = JSON.stringify(winLine);
            
            // Horizontal
            if (line === '["A1","B1","C1","D1"]' || line === '["A2","B2","C2","D2"]' || 
                line === '["A3","B3","C3","D3"]' || line === '["A4","B4","C4","D4"]') {
                return 'horizontal';
            }
            
            // Vertikal
            if (line === '["A1","A2","A3","A4"]' || line === '["B1","B2","B3","B4"]' ||
                line === '["C1","C2","C3","C4"]' || line === '["D1","D2","D3","D4"]') {
                return 'vertical';
            }
            
            // Diagonal
            if (line === '["A1","B2","C3","D4"]') {
                return 'diagonal-main';
            }
            
            if (line === '["D1","C2","B3","A4"]') {
                return 'diagonal-anti';
            }
            
            return 'unknown';
        }
        
        function getLineIdentifier(winLine) {
            const line = JSON.stringify(winLine);
            
            switch(line) {
                case '["A1","B1","C1","D1"]': return 'a1d1';
                case '["A2","B2","C2","D2"]': return 'a2d2';
                case '["A3","B3","C3","D3"]': return 'a3d3';
                case '["A4","B4","C4","D4"]': return 'a4d4';
                case '["A1","A2","A3","A4"]': return 'a1a4';
                case '["B1","B2","B3","B4"]': return 'b1b4';
                case '["C1","C2","C3","C4"]': return 'c1c4';
                case '["D1","D2","D3","D4"]': return 'd1d4';
                case '["A1","B2","C3","D4"]': return 'a1d4';
                case '["D1","C2","B3","A4"]': return 'd1a4';
                default: return 'unknown';
            }
        }
        
        function findWinningLine() {
            const lines = [
                ['A1', 'B1', 'C1', 'D1'],
                ['A2', 'B2', 'C2', 'D2'],
                ['A3', 'B3', 'C3', 'D3'],
                ['A4', 'B4', 'C4', 'D4'],
                ['A1', 'A2', 'A3', 'A4'],
                ['B1', 'B2', 'B3', 'B4'],
                ['C1', 'C2', 'C3', 'C4'],
                ['D1', 'D2', 'D3', 'D4'],
                ['A1', 'B2', 'C3', 'D4'],
                ['D1', 'C2', 'B3', 'A4']
            ];
            
            for (const line of lines) {
                const colors = line.map(pos => gameBoard[pos]).filter(Boolean);
                if (colors.length === 4 && colors.every(color => color === colors[0])) {
                    return line;
                }
            }
            
            return null;
        }
        
        // ==================================================================================
        // INITIALISIERUNG
        // ==================================================================================
        
        document.addEventListener('DOMContentLoaded', function() {
            // Erkenne Hosting-Modus
            detectHostingMode();
            
            // Prüfe URL-Parameter (HTTPS-Modus)
            const urlParams = new URLSearchParams(window.location.search);
            const joinCode = urlParams.get('join');
            const stunServer = urlParams.get('stun');
            
            if (joinCode && isHttpsMode) {
                // Automatischer Beitritt über URL
                debugLog(`URL-Beitritt erkannt: ${joinCode}`);
                isHost = false;
                sessionStorage.setItem('game_code', joinCode);
                sessionStorage.setItem('stun_server', stunServer || 'stun:stun.l.google.com:19302');
                sessionStorage.setItem('is_host', 'false');
                
                // Springe direkt zur Spieler-Seite
                document.getElementById('setupPage').classList.remove('active');
                document.getElementById('playerPage').classList.add('active');
                initializeWebRTC();
            } else {
                // Normaler Start - generiere Code
                generateInviteCode();
            }
            
            // Event Listeners
            document.getElementById('playerName').addEventListener('input', updateEnterGameButton);
            
            // Code-Eingabe mit Enter-Key
            document.getElementById('gameCodeInput').addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    joinWithCode();
                }
            });
            
            // Code-Eingabe Formatierung
            document.getElementById('gameCodeInput').addEventListener('input', function(event) {
                event.target.value = event.target.value.toUpperCase().replace(/[^ABCDEFGHJKLMNPQRSTUVWXYZ23456789]/g, '');
            });
            
            // Chat Input Enter-Key
            document.getElementById('chatInput').addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    sendChatMessage();
                }
            });
            
            // Verhindere Standardverhalten für Touch-Events auf Spielbrett
            document.getElementById('orbitoBoard').addEventListener('touchmove', function(event) {
                event.preventDefault();
            }, { passive: false });
            
            debugLog('Online-Spiel HYBRID-VERSION (FIXED) geladen!');
        });
        
        // Cleanup beim Seitenverlassen
        window.addEventListener('beforeunload', function() {
            if (peerConnection) {
                peerConnection.close();
            }
            
            // Cleanup localStorage für diese Session
            const gameCode = sessionStorage.getItem('game_code');
            if (gameCode) {
                localStorage.removeItem(`game_offer_${gameCode}`);
                localStorage.removeItem(`game_answer_${gameCode}`);
                localStorage.removeItem(`game_ice_${gameCode}`);
            }
            
            debugLog('Cleanup beim Seitenverlassen durchgeführt');
        });
    </script>
</body>
</html>